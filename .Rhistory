# Add data layer
geom_polygon(data = state_join, aes(fill = Confirmed), color = "white") +
scale_fill_gradientn(colors = brewer.pal(n = 5, name = "BuGn"),
trans = "log10") +
labs(title = "COVID-19 Confirmed Cases in Massachusetts'")
daily_report
library(plotly)
ggplotly(
ggplot(data = ma_county, mapping = aes(x = long, y = lat, group = group)) +
coord_fixed(1.3) +
# Add data layer
geom_polygon(data = state_join, aes(fill = Confirmed), color = "black") +
scale_fill_gradientn(colours =
wes_palette("Zissou1", 100, type = "continuous")) +
ggtitle("COVID-19 Cases in MA") +
# Cleaning up the graph
labs(x=NULL, y=NULL) +
theme(panel.border = element_blank()) +
theme(panel.background = element_blank()) +
theme(axis.ticks = element_blank()) +
theme(axis.text = element_blank())
)
# Read in the daily report
daily_report <- read_csv(url("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/09-26-2020.csv")) %>%
rename(Long = "Long_") %>%
group_by(Country_Region) %>%
summarize(Confirmed = sum(Confirmed), Deaths = sum(Deaths))
# Read in the world map data
world <- as_tibble(map_data("world"))
# Check to see if there are differences in the naming of countries
setdiff(world$region, daily_report$Country_Region)
# Many of these countries are considered states or territories in the JHU covid reports,
# but let's fix a few of them
world <- as_tibble(map_data("world")) %>%
mutate(region = str_replace_all(region, c("USA" = "US", "Czech Republic" = "Czechia",
"Ivory Coast" = "Cote d'Ivoire", "Democratic Republic of the Congo" = "Congo (Kinshasa)",
"Republic of Congo" = "Congo (Brazzaville)")))
# Join the covid report with the map data
country_join <- left_join(world, daily_report, by = c("region" = "Country_Region"))
# Create the graph
ggplotly(
ggplot(data = world, mapping = aes(x = long, y = lat, text = region, group = group)) +
coord_fixed(1.3) +
# Add data layer
geom_polygon(data = country_join, aes(fill = Deaths), color = "black") +
scale_fill_gradientn(colours =
wes_palette("Zissou1", 100, type = "continuous")) +
labs(title = "COVID-19 Deaths")
)
daily_report_1 <- read_csv(url("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/09-26-2020.csv")) %>%
rename(Long = "Long_")
ggplot(daily_report_1, aes(x = Long, y = Lat, size = Confirmed/1000)) +
borders("world", colour = "pink", fill = "grey") +
theme_minimal() +
geom_point(shape = 21, color='gold', fill='magenta', alpha = 0.5) +
labs(title = 'World COVID-19 Confirmed cases',x = '', y = '',
size="Cases (x1000))") +
theme(legend.position = "right") +
coord_fixed(ratio=1.5)
daily_report_2 <-   read_csv(url("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/09-26-2020.csv")) %>%
rename(Long = "Long_") %>%
filter(Country_Region == "US") %>%
filter (!Province_State %in% c("Alaska","Hawaii", "American Samoa",
"Puerto Rico","Northern Mariana Islands",
"Virgin Islands", "Recovered", "Guam", "Grand Princess",
"District of Columbia", "Diamond Princess")) %>%
filter(Lat > 0)
### Change made to Range from c(1,7) to c(1.5) from Better Visualization
mybreaks <- c(100, 1000, 10000, 100000, 1000000)
ggplot(daily_report_2, aes(x = Long, y = Lat, size = Confirmed)) +
borders("state", colour = "white", fill = "grey90") +
geom_point(aes(x=Long, y=Lat, size=Confirmed, color=Confirmed),stroke=F, alpha=0.7) +
scale_size_continuous(name="Cases", trans="log", range=c(1,5),
breaks=mybreaks, labels = c("100-999",
"1,000-9,999", "10,000-99,999", "100,000-999,999", "1,000,000-9,999,999")) +
scale_color_viridis_c(option="viridis",name="Cases",
trans="log", breaks=mybreaks, labels = c("100-999",
"1,000-9,999", "10,000-99,999", "100,000-999,999", "1,000,000-9,999,999"))  +
# Cleaning up the graph to update date (9/26/20)
theme_void() +
guides( colour = guide_legend()) +
labs(title = "Anisa Dhana's lagout for COVID-19 Confirmed Cases in the US (9/26/20)") +
theme(
legend.position = "bottom",
text = element_text(color = "#22211d"),
plot.background = element_rect(fill = "#ffffff", color = NA),
panel.background = element_rect(fill = "#ffffff", color = NA),
legend.background = element_rect(fill = "#ffffff", color = NA)
) +
coord_fixed(ratio=1.5)
report_09_26_2020 <-   read_csv(url("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/09-26-2020.csv")) %>%
rename(Long = "Long_") %>%
unite(Key, Admin2, Province_State, sep = ".") %>%
group_by(Key) %>%
summarize(Confirmed = sum(Confirmed)) %>%
mutate(Key = tolower(Key))
# dim(report_09_26_2020)
# get and format the map data
us <- map_data("state")
counties <- map_data("county") %>%
unite(Key, subregion, region, sep = ".", remove = FALSE)
# Join the 2 tibbles
state_join <- left_join(counties, report_09_26_2020, by = c("Key"))
# sum(is.na(state_join$Confirmed))
ggplot(data = us, mapping = aes(x = long, y = lat, group = group)) +
coord_fixed(1.3) +
# Add data layer
borders("state", colour = "black") +
geom_polygon(data = state_join, aes(fill = Confirmed)) +
scale_fill_gradientn(colors = brewer.pal(n = 5, name = "Pastel1"),
breaks = c(1, 10, 100, 1000, 10000, 100000),
trans = "log10", na.value = "White") +
ggtitle("Number of Confirmed Cases by US County") +
theme_minimal()
#Make an interactive plot using a state of your chosing using a theme different from used in the above exammples.
#Change Massachusetts to Hawaii
daily_report_4 <-   read_csv(url("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_daily_reports/09-26-2020.csv")) %>%
rename(Long = "Long_") %>%
filter(Province_State == "New York") %>%
group_by(Admin2) %>%
summarize(Confirmed = sum(Confirmed)) %>%
mutate(Admin2 = tolower(Admin2))
US4 <- map_data("state")
ny_us <- subset(US4, region == "new york")
counties <- map_data("county")
ny_county <- subset(counties, region == "new york")
state_join_ex4 <- left_join(ny_county, daily_report_4, by = c("subregion" = "Admin2"))
# plot state map
ggplotly(
ggplot(data = ny_county, mapping = aes(x = long, y = lat, group = group)) +
coord_fixed(1.3) +
# Add data layer
geom_polygon(data = state_join_ex4, aes(fill = Confirmed), color = "white") +
ggtitle("COVID-19 Cases in NY (9/26/20)") +
theme(axis.line = element_blank(), axis.text = element_blank(),
axis.ticks = element_blank(), axis.title = element_blank()) +
scale_fill_viridis(option="plasma")
)
library(shiny)
runExample("01_hello")
library(shiny)
runExample("01_hello")
BiocManager::install(version = "3.11")
install.packages("BiocManager")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
library(tidyverse)
library(ggtree)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
library(tidyverse)
library(tibble)
library(tidyr)
library(tibble)
str_view(x, "an")
x <- c("apple", "banana", "pear")
str_view(x, "an")
str_view(x, ".a.")
# But the expression itself only contains one:
writeLines(dot)
# To create the regular expression, we need \\
dot <- "\\."
# But the expression itself only contains one:
writeLines(dot)
str_view(x, "a\\.c")
x <- c("abc", "a.c", "bef")
str_view(x, "a\\.c")
writeLines(x)
x <- "a\\b"
writeLines(x)
str_view(x, "\\\\")
str_view(x, "^a")
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
str_view(x, "apple")
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x, "a$")
str_view(x, "a$")
str_view(x, "a$")
str_view(x, "a$")
str_view(x, "a$")
str_view(x, "a$")
library(stringr)
library(tidyverse)
library(tidyr)
library(tibble)
x <- c("apple", "banana", "pear")
str_view(x, "an")
str_view(x, ".a.")
# To create the regular expression, we need \\
dot <- "\\."
# But the expression itself only contains one:
writeLines(dot)
x <- c("abc", "a.c", "bef")
str_view(x, "a\\.c")
x <- "a\\b"
writeLines(x)
str_view(x, "\\\\")
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
str_view(x, "apple")
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x, "^apple$")
str_view(x, "$^$")
str_view(x, "a[.]c")
# Look for a literal character that normally has special meaning in a regex
x <- c("abc", "a.c", "a*c", "a c")
str_view(x, "a[.]c")
str_view(x, ".[*]c")
str_view(x, "a[ ]")
str_view(x, "gr(e|a)y")
#To pick either one or the other
x <- c("grey", "gray")
str_view(x, "gr(e|a)y")
```{r}
#To pick either one or the other
x <- c("grey", "gray")
str_view(x, "gr(e|a)y")
str_subset(stringr::words, "^[aeiou]")
str_subset(stringr::words, "^[aeiou]")
# Same things as above but NO MATCHES
str_subset(stringr::words, "[aeiou]", negate=TRUE)
# Words ending with ed but no eed
str_subset(stringr::words, "[^e]ed$")
#Words ending with either ing or ise
str_subset(stringr::words, "i(ng|se)$")
str_view(x, "CC?")
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "CC+")
str_view(x, "CC+")
str_view(x, 'C[LX]+')
str_view(x, "C{2}")
str_view(x, "C{2,}")
str_view(x, "C{2,}")
str_view(x, 'C{2,3}?')
str_view(x, 'C[LX]+?')
#The (..)\\1 finds 2 letters in series which match each other.
str_view(fruit, "(..)\\1", match = TRUE)
#The (..)\\1 finds 2 letters in series which match each other.
str_view(fruit, "(..)\\1", match = TRUE)
#The (..)\\1 finds 2 letters in series which match each other.
str_view(fruit, "(..)\\1", match = TRUE)
```{r}
str_view(fruit, "(..)\\1", match = TRUE)
#The (..)\\1 finds 2 letters in series which match each other.
str_view(fruit, "(..)\\1", match = TRUE)
#The (..)\\1 finds 2 letters in series which match each other.
str_view(fruit, "(..)\\1", match = TRUE)
str_view(fruit, "(..)\\1", match = TRUE)
# 14.3.5 Grouping and backreferences
```{r}
str_view(fruit, "(..)\\1", match = TRUE)
```
# 14.3.5 Grouping and backreferences
```{r}
str_view(stringr::words, "(.)\1\1", match = TRUE)
str_view(stringr::words, "(.)\1\1", match = TRUE)
14.4 Tools
str_detect(x, "e")
x <- c("apple", "banana", "pear")
str_detect(x, "e")
# How many common words start with t?
sum(str_detect(words, "^t"))
# What proportion of common words end with a vowel?
mean(str_detect(words, "[aeiou]$"))
# Find all words containing at least one vowel, and negate
no_vowels_1 <- !str_detect(words, "[aeiou]")
identical(no_vowels_1, no_vowels_2)
# Find all words containing at least one vowel, and negate
no_vowels_1 <- !str_detect(words, "[aeiou]")
# Find all words consisting only of consonants (non-vowels)
no_vowels_2 <- str_detect(words, "^[^aeiou]+$")
identical(no_vowels_1, no_vowels_2)
words[str_detect(words, "x$")]
str_subset(words, "x$")
df %>%
filter(str_detect(word, "x$"))
df %>%
filter(str_detect(word, "x$"))
df %>%
filter(str_detect(word, "x$"))
df %>%
filter(str_detect(word, "x$"))
df <- tibble(
word = words,
i = seq_along(word)
)
df %>%
filter(str_detect(word, "x$"))
str_count(x, "a")
library(stringr)
library(tidyverse)
library(stringr)
library(tidyverse)
library(tidyr)
library(tibble)
x <- c("apple", "banana", "pear")
str_view(x, "an")
str_view(x, ".a.")
# To create the regular expression, we need \\
dot <- "\\."
# But the expression itself only contains one:
writeLines(dot)
x <- c("abc", "a.c", "bef")
str_view(x, "a\\.c")
x <- "a\\b"
writeLines(x)
str_view(x, "\\\\")
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x, "^apple$")
str_view(x, "$^$")
# Look for a literal character that normally has special meaning in a regex
x <- c("abc", "a.c", "a*c", "a c")
str_view(x, "a[.]c")
str_view(x, ".[*]c")
str_view(x, "a[ ]")
#To pick either one or the other
x <- c("grey", "gray")
str_view(x, "gr(e|a)y")
str_subset(stringr::words, "^[aeiou]")
# Same things as above but NO MATCHES
str_subset(stringr::words, "[aeiou]", negate=TRUE)
# Words ending with ed but no eed
str_subset(stringr::words, "[^e]ed$")
#Words ending with either ing or ise
str_subset(stringr::words, "i(ng|se)$")
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "CC+")
str_view(x, 'C[LX]+')
str_view(x, "C{2}")
str_view(x, "C{2,}")
str_view(x, "C{2,}")
str_view(x, 'C{2,3}?')
str_view(x, 'C[LX]+?')
str_view(fruit, "(..)\\1", match = TRUE)
# On average, how many vowels per word?
mean(str_count(words, "[aeiou]"))
df %>%
mutate(
vowels = str_count(word, "[aeiou]"),
consonants = str_count(word, "[^aeiou]")
)
df %>%
mutate(
vowels = str_count(word, "[aeiou]"),
consonants = str_count(word, "[^aeiou]")
)
str_count("abababa", "aba")
str_view_all("abababa", "aba")
vowel?
#Either start with x, or end with x
words[str_detect(words, "^x|x$")]
vowel?
#Either start with x, or end with x
words[str_detect(words, "^x|x$")]
```{r}
vowel?
#Either start with x, or end with x
words[str_detect(words, "^x|x$")]
vowel?
#Either start with x, or end with x
words[str_detect(words, "^x|x$")]
```{r}
#Either start with x, or end with x
words[str_detect(words, "^x|x$")]
#Either start with x, or end with x
words[str_detect(words, "^x|x$")]
df %>%
filter(str_detect(word, "x$"))
#All words starting with a vowel, with anything inbetween, and then ending with smething that is not a vowel
str_subset(words, "^[aeiou].*[^aeiou]$")
#Contain one of each vowel at least
words[str_detect(words, "a") &
str_detect(words, "e") &
str_detect(words, "i") &
str_detect(words, "o") &
str_detect(words, "u")]
length(sentences)
head(sentences)
colour_match
colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
head(matches)
has_colour
has_colour
```{r}
has_colour
library(stringr)
library(tidyverse)
library(tidyr)
library(tibble)
x <- c("apple", "banana", "pear")
str_view(x, "an")
str_view(x, ".a.")
# To create the regular expression, we need \\
dot <- "\\."
# But the expression itself only contains one:
writeLines(dot)
x <- c("abc", "a.c", "bef")
str_view(x, "a\\.c")
x <- "a\\b"
writeLines(x)
str_view(x, "\\\\")
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x, "^apple$")
str_view(x, "$^$")
# Look for a literal character that normally has special meaning in a regex
x <- c("abc", "a.c", "a*c", "a c")
str_view(x, "a[.]c")
str_view(x, ".[*]c")
str_view(x, "a[ ]")
#To pick either one or the other
x <- c("grey", "gray")
str_view(x, "gr(e|a)y")
str_subset(stringr::words, "^[aeiou]")
# Same things as above but NO MATCHES
str_subset(stringr::words, "[aeiou]", negate=TRUE)
# Words ending with ed but no eed
str_subset(stringr::words, "[^e]ed$")
#Words ending with either ing or ise
str_subset(stringr::words, "i(ng|se)$")
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
str_view(x, "CC+")
str_view(x, 'C[LX]+')
str_view(x, "C{2}")
str_view(x, "C{2,}")
str_view(x, "C{2,}")
str_view(x, 'C{2,3}?')
str_view(x, 'C[LX]+?')
str_view(fruit, "(..)\\1", match = TRUE)
str_view(stringr::words, "(.)\1\1", match = TRUE)
x <- c("apple", "banana", "pear")
str_detect(x, "e")
# How many common words start with t?
sum(str_detect(words, "^t"))
# What proportion of common words end with a vowel?
mean(str_detect(words, "[aeiou]$"))
# Find all words containing at least one vowel, and negate
no_vowels_1 <- !str_detect(words, "[aeiou]")
# Find all words consisting only of consonants (non-vowels)
no_vowels_2 <- str_detect(words, "^[^aeiou]+$")
identical(no_vowels_1, no_vowels_2)
words[str_detect(words, "x$")]
str_subset(words, "x$")
df <- tibble(
word = words,
i = seq_along(word)
)
df %>%
filter(str_detect(word, "x$"))
x <- c("apple", "banana", "pear")
str_count(x, "a")
# On average, how many vowels per word?
mean(str_count(words, "[aeiou]"))
df %>%
mutate(
vowels = str_count(word, "[aeiou]"),
consonants = str_count(word, "[^aeiou]")
)
str_count("abababa", "aba")
str_view_all("abababa", "aba")
#Either start with x, or end with x
words[str_detect(words, "^x|x$")]
#All words starting with a vowel, with anything inbetween, and then ending with smething that is not a vowel
str_subset(words, "^[aeiou].*[^aeiou]$")
#Contain one of each vowel at least
words[str_detect(words, "a") &
str_detect(words, "e") &
str_detect(words, "i") &
str_detect(words, "o") &
str_detect(words, "u")]
length(sentences)
head(sentences)
colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
has_colour <- str_subset(sentences, colour_match)
matches <- str_extract(has_colour, colour_match)
head(matches)
has_colour
str_view_all(more, colour_match)
more <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more, colour_match)
str_extract(more, colour_match)
str_extract_all(more, colour_match)
str_extract_all(more, colour_match, simplify = TRUE)
str_extract_all(x, "[a-z]", simplify = TRUE)
colour_match2
# \b indicates a word boundary. THis means only look for actual colors, not peices of words which happen to be colors.
colour_match2 <- str_c("\\b(", str_c(colours, collapse = "|"), ")\\b")
colour_match2
str_view_all(more2, colour_match2, match = TRUE)
more2 <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more2, colour_match2, match = TRUE)
